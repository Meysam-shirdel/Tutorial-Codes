# -*- coding: utf-8 -*-
"""Clustering-Tuned.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14mD-SJwOeiG8QdLcyX6M4X89eF-JTbxN
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.text as plttext
from mpl_toolkits.mplot3d import Axes3D 
import matplotlib.colors as mc
from scipy.spatial import distance
from sklearn import datasets 
from sklearn import metrics
from sklearn.preprocessing import minmax_scale,StandardScaler

#import tensorflow as tf
#import tensorflow_probability as tfp

import statistics as statics
import seaborn as sns

import time

data = np.array(pd.read_excel('flame.xlsx'))

data = np.unique(data,axis=0)
N = len(data)

data = np.array(pd.read_csv('circles.csv'))
data = np.unique(data,axis=0)
N = len(data)

data = minmax_scale(data)
plt.plot(data[:, 0], data[:, 1], 'b.')

def mycluster (noise_threshold=1, use_center=False, text='' ):
  start_time = time.time()

  dist_matrix = distance.cdist(data, data, 'euclidean')
  for ii in range(N):
    dist_matrix[ii, ii] = np.inf
  min1 = dist_matrix.min(axis=1)
  gridlength = min1.min(axis=0) 
  maxmin = min1.max(axis=0)
  noiseradius = np.math.ceil((maxmin / gridlength)/2)

#noise_threshold = 85
  cluster_number = np.zeros((N, 1))
  added_to_neighbor = np.zeros((N,1))

  noise = []
  non_noise = []
  biglist = []
  for i in range(N):
    bli = np.argwhere((dist_matrix[i] / gridlength)/2 < noiseradius)
    if len(bli)< noise_threshold:
      noise.append(i)
      cluster_number[i] = -1
    else:
      non_noise.append(i)

    biglist.append( bli)

  noise = np.reshape(noise, (len(noise), 1))
  if len(noise)>0:
    noise_data = data[noise]
    noise_data = noise_data.reshape(len(noise_data),data.shape[1])
    non_noise_data =  data[non_noise] # np.delete(data, noise, axis=0)
  else:
    non_noise_data = data


#--------------------------------------------
  num_not_clustered = len(non_noise_data)
  non_noise_backup = non_noise
  index = np.random.randint(0, len(data))
  neighborlist = []
  clusters = [-1]
  current_cluster = 0


  while num_not_clustered > 0:
    current_cluster += 1
    gg = 0
    while cluster_number[index] in clusters:
      index = np.random.randint(0, len(data))

    clusters.append(current_cluster)
    neighborlist.append(index)
    cluster = []
    while len(neighborlist) > 0:
      index = neighborlist.pop(0)
      cluster_number[index] = current_cluster
      num_not_clustered -= 1
      #lstn = biglist[index] #np.argwhere(((dist_matrix[index,:] / gridlength)/2) < noiseradius)

      for j in range(len(biglist[index])):
        if cluster_number[biglist[index][j]] == 0:
          cluster_number[biglist[index][j]] = current_cluster
          if added_to_neighbor[biglist[index][j]]== 0:
            neighborlist.append(np.int(biglist[index][j,0]))  
            added_to_neighbor[biglist[index][j]]= 1

     
  clusters.pop(0)

  if len(clusters) > 6:
    colors = np.zeros((len(clusters),3))
    for co in range(len(clusters)):
      colors[co] = np.random.rand(1,3)
  else:
    colors = ['green','magenta','cyan','blue','yellow','black']

  st = plttext.Text()
  cluster_centers = np.zeros((len(clusters),2))
  for i in range(len(clusters)):
    X = data[np.where(cluster_number == i+1)[0], 0]
    Y = data[np.where(cluster_number == i+1)[0], 1]
    cluster_centers[i,0] = statics.mean(X)
    cluster_centers[i,1] = statics.mean(Y)
    
  if use_center == True:
    for k  in range(len(noise)):
      dist_from_center =distance.cdist(data[noise[k]][0].reshape(1,len(data[noise[k]][0])), cluster_centers, 'euclidean')
      sortedneighbor = np.argmin(dist_from_center[0,:])
      cluster_number[noise[k]] = sortedneighbor+1

  else:
    for k  in range(len(cluster_number)):
      if cluster_number[k] == -1:
        sortedneighbor = np.argsort(dist_matrix[k,:])
        m = 0
        while  cluster_number[sortedneighbor[m]] ==-1:
          m += 1
    
        cluster_number[k] = cluster_number[sortedneighbor[m]]
    '''for k  in range(len(cluster_number)):
      if cluster_number[k] == -1:
        sortedneighbor = np.argsort(np.where(cluster_number[biglist[k][:]]!=-1))
        m = 0
        while  cluster_number[sortedneighbor[m]] ==-1:
          m += 1
    
        cluster_number[k] = cluster_number[sortedneighbor[m]]'''

    
  end_time = time.time() 

  for i in range(len(clusters)):
    X = data[np.where(cluster_number == i+1)[0], 0]
    Y = data[np.where(cluster_number == i+1)[0], 1]
    plt.plot(X, Y, marker='.', linestyle='', color=colors[i], markersize=5 )
    #plt.plot(cluster_centers[i,0], cluster_centers[i,1],marker=str(i), markersize=10, color='black')
    plt.text(cluster_centers[i,0], cluster_centers[i,1],str(i+1), color='red',ha="center", va="center",fontsize=12,fontweight='bold')

  plt.title(text)
  #plt.text(-0.5, 0.7, 'Clustering took {:.2f} s'.format(end_time - start_time), fontsize=14)

mycluster(noise_threshold= 1, use_center= False, text='Concentration Coefficients= 1, use_center= False')


