# -*- coding: utf-8 -*-
"""Untitled31.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/185-boLCKaU2XgdrS_MM13UP219PZRNEj
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import distance
from sklearn import datasets

import tensorflow as tf
import tensorflow_probability as tfp

data3 = datasets.make_gaussian_quantiles(n_samples= 400)[0]
plt.plot(data3[:, 0], data3[:, 1], 'b.')

NC = 400
data1 = datasets.make_moons(NC, noise=0)[0]
data2 = datasets.make_circles(NC , noise=0.1)[0]+(2,-2)
data3 = datasets.make_gaussian_quantiles(n_samples= 400)[0]+[-3,-2]
data4 = np.random.uniform(-3,3,(2000,2))
data = np.concatenate((data1, data2, data4), axis=0)
#data = data1
N = len(data)
plt.plot(data[:, 0], data[:, 1], 'b.')
plt.show()

N = 500
tfd = tfp.distributions
nd = tfd.Normal(loc=0 , scale= 1,)
nd2 = tfd.Normal(loc=0 , scale= 1,)
d1 = nd.sample((N/2,2))
d2 = nd2.sample((N/2,2))+(3,-5)
data = np.concatenate((d1,d2), axis=0)
plt.plot(data[:,0], data[:,1], 'b.')
#plt.hist(d, bins=50, density=Tru

AA =distance.cdist(data, data, 'euclidean')
for i in range(N):
  AA[i, i] = np.inf
min1 = AA.min(axis=1)
gridlength = min1.min() - 0.0001
maxmin = min1.max(axis=0)

noiseradius = np.math.ceil((maxmin / gridlength)/2)

noisey = np.zeros((N, 1))
noise = []
for i in range(N):
  sortedidx = np.argsort(AA[i, :])
  j = 0
  num_neighbor= 0
  while ((AA[i, sortedidx[j]] / gridlength)/2) < noiseradius:
    num_neighbor += 1
    j += 1

  if num_neighbor < 25:
    noise.append(i)
    noisey[i] = -1

noise = np.reshape(noise, (len(noise), 1))
noise_data = data[noise]
noise_data = noise_data.reshape(len(noise_data),2)
non_noise_data = np.delete(data, noise, axis=0)

plt.plot(noise_data[:, 0], noise_data[:, 1], 'r.')
plt.plot(non_noise_data[:, 0], non_noise_data[:, 1], 'b.')
plt.show()

len(noise_data)/ len(non_noise_data)

n_not_clustered = len(non_noise_data)
index = np.random.randint(0, len(data))
neighborlist = []
clusters = [-1]
current_cluster = 0
while n_not_clustered > 0:
  current_cluster += 1
  while noisey[index] in clusters:
    index = np.random.randint(0, len(data))

  clusters.append(current_cluster)
  #noisey[index] = current_cluster
  neighborlist.append(index)

  #n_not_clustered -= len(neighborlist)

  cluster = []
  while len(neighborlist) > 0:
    index = neighborlist.pop(0)
    noisey[index] = current_cluster
    n_not_clustered -= 1
    sortedidx2 = np.argsort(AA[index, :])
    j = 0
    while (((AA[index, sortedidx2[j]] )/gridlength)/2) < noiseradius:  # and (noisey[sortedidx2[j]] == 0):
      if noisey[sortedidx2[j]] == 0:
        if sortedidx2[j] not in neighborlist:
          neighborlist.append(sortedidx2[j])
          j += 1
        else: 
          j += 1
      else:
        j += 1
      

clusters.pop(0)

plt.figure(4)
plt.plot(noise_data[:, 0], noise_data[:, 1], 'r.')
plt.plot(non_noise_data[:, 0], non_noise_data[:, 1], 'b.')

colors =['k.','g.','c.','m.','y.','k.','w.']
for i in range(len(clusters)):
  plt.plot(data[np.where(noisey == i+1), 0], data[np.where(noisey == i+1), 1], colors[i], markersize=10)

plt.show()

condition = (noisey != -1)
noisey[condition] = 0